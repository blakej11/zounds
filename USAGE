I wanted the display to be totally focused on the generated image, so there
are no immediate visual cues to the controls.  All control is done via
keyboard input, with the exception of one thing that can be done via mouse.
In order to see any text output from the program, it must be run from
within a terminal window.

The program is fairly well-suited for an individual to play around with on
a laptop, since that has basic versions of everything that's really needed:
a display, a GPU, a keyboard, a mouse or trackpad, and a camera. But it's
much more fun to create a dedicated installation for running it.

The rest of this section will describe some of the features of the program,
along with the keystrokes used to activate them.  Typing ? at any time will
display a brief summary of the keystrokes available.

- Window size				('f', escape)

  The program runs in full-screen mode by default.  The 'f' key toggles
  between full-screen mode and smaller window mode, and the <escape> key
  drops it out of full-screen mode.  The smaller window can be resized like
  usual, but due to some implementation constraints, some window sizes
  might have small black borders around the actual image.

- Animation				(space, enter)

  By default, the program generates and displays images as quickly as it
  can, making it appear animated.  Pressing <space> toggles animation on
  and off. When animation is off, pressing <enter> generates and displays
  a single new image.

- Saving images				('s', 'S')

  The 's' key saves the currently displayed image as a PPM file in the
  directory "./images/latest/".  The 'S' key toggles "save all images"
  mode; when it is enabled, each new image is saved as a PPM file.  (This
  generates a substantial amount of data very quickly!)

- Tunable parameters and autopilot	('a')

  Each algorithm has some parameters that can be changed while it is
  running.  The next section describes the parameters that are available
  for each algorithm.  By default, the program runs in "autopilot" mode,
  where it will adjust parameters at random to create an interesting
  display.  The 'a' key toggles autopilot mode; when it is off, the
  parameters can be changed by the tuning commands, as described below.
  Using any of the explicit tuning commands turns off autopilot.

- Loading a starting image		('r', 'c', -F command-line option)

  There are a few ways to start the algorithm running from a new image.
  Pressing 'r' will fill the image with random values.  Pressing 'c' will
  take a picture from the machine's built-in camera, if one is available
  and the program is configured to use OpenCV.  Starting the program with
  the "-F <filename>" command-line option will load in the PPM file
  <filename> as a starting image.

- Heatmap				('h', 'H')

  Each algorithm maintains some data for each pixel in the image.  Simpler
  algorithms might maintain just a single value, which gets translated
  directly into a simple color, such as a greyscale value.  Other
  algorithms maintain multiple values (a vector) per pixel, and have a more
  complex translation between the vector values and the resulting pixel
  color.

  During development of this program, I found it useful to be able to see
  how these values are distributed.  For single-value algorithms, this is
  fairly straightforward - a histogram plotting pixel value against
  frequency of pixel value gets the job done.  (See the 'x' option below.)
  But vector-valued algorithms are harder, since the screen only has two
  dimensions.  To deal with this, I created a "heatmap" mode, which uses
  two components of the vector as X and Y coordinates, and uses the color
  of the resulting pixel to indicate how frequently those coordinates were
  represented in the data.  In other words, this takes the cloud of
  N-dimensional points represented by all the vector values, and projects
  it onto 2-space.

  The 'h' key toggles the use of this heatmap visualization mode.  There
  are three states that it toggles between: regular display;
  picture-in-picture mode, which displays a small heatmap in the lower
  right corner; and full heatmap mode.

  As it happens, the patterns generated by this mode are often at least as
  visually interesting as the regular rendering mode!

- Histogram				('x')

  This displays an ASCII-art histogram for each vector component of all of
  the data points in the current image.

- Mouse					(click and drag, '[', '{', ']', '}')

  The mouse can be used to interact with the image.  Clicking and dragging
  within the image gives an effect like sticking a finger into a vat of
  colored ink and dragging it around.  This uses an algorithm from Aubrey
  Jaffer's paper "Oseen Flow in Ink Marbling".  The '['/'{' key decreases
  the viscosity of the image, and the ']'/'}' key increases the viscosity.

- Debugging				('v', 'D' + various)

  The 'v' key toggles verbose mode. When in verbose mode, the program
  prints text messages describing some of its more visible actions: changes
  to parameters, enabling/disabling autopilot, names of saved images, etc.

  The 'D' key enables toggling various debugging modes.  When enabled, each
  debugging mode gives more verbose output about the action of some
  subsystem of the program.  Typing 'D' '?' gives a list of all the areas
  that can have debugging toggled; for example, 'D' 'P' toggles the display
  of image generation performance.

------------------------------------------------------------------------

Turing clouds + MSTP (Multi-Scale Turing Patterns)

This is an implementation of the algorithm described in Jonathan McCabe's
paper "Cyclic Symmetric Multi-Scale Turing Patterns".  I've described it
in detail at https://foo.net/projects/turing-clouds/background.html .
Notably, Turing clouds and MSTP share many parts of the same
implementation, though with different data types and rendering methods.

There are five parameters to these algorithms that can be tweaked:

- Scales				(',', '<', '.', '>')

  These algorithms use 9 different scales (averages around 9 different
  radii) to determine how to update each pixel.  The ','/'<' key decreases
  the number of scales used, and the '.'/'>' key increases the number of
  scales.  Scales are removed from smallest to largest, so when the minimum
  number (2) of scales are in use, the only features in the image are
  large-scale.

- Speed					('-', '_', '=', '+')

  By default, each new image changes the pixel's value by <1% compared to
  its previous value.  Increasing this update amount makes it appear that
  the algorithm is moving faster - like more frames are being calculated in
  the same amount of time.  In reality, though, this just makes each update
  larger and jumpier.  The '-'/'_' key decreases the update amount, and the
  '+'/'=' key increases it.

- Box blur				('b', 'B')

  Calculating the average value of all the pixels in some radius around
  every pixel in the image is very computationally expensive, especially
  when the radii are large (256 pixels).  Since it's not important to get
  the precise average, this implementation uses a box blur to approximate
  getting an average value within a circle.  Using multiple passes of the
  box blur gives a better approximation of a circle, but increases the
  computational workload quite a bit.  By default, this implementation uses
  two passes (since that looks nice), but that can be decreased with the
  'b' key and increased with the 'B' key.

- Adjustment values			('j', 'J')

  The adjustment given to each pixel is chosen by which pair of scales
  gives the smallest difference in average values.  But this just decides
  which adjustment to make; each scale-pair has a specific adjustment
  amount associated with it.  Changing the adjustment amounts gives
  visually distinct styles of images.  There isn't a way to change the
  adjustments directly at run-time, but there are a handful of predefined
  adjustment sets, and the 'j' and 'J' keys cycle through those predefined
  sets.  (Internally they're indexed from 0 to 7; 'j' moves to smaller
  index values and 'J' moves to larger index values.)

------------------------------------------------------------------------

John Conway's Game of Life

This is one of the oldest and most widely known cellular automata. It isn't
as visually interesting as Turing clouds/MSTP; I mainly implemented it as a
proof of concept to make sure the framework allowed me to write it easily.

There is one parameter to this algorithm that can be tweaked:

- Aliveness				('-', '_', '=', '+')

  Each pixel has a value between 0 and 1. Any pixels whose value is at or
  above the aliveness threshold are considered alive from the perspective
  of the Game of Life algorithm.  Pixels that are alive for multiple
  timesteps in a row decrease their value linearly down to the threshold,
  and the color of a pixel is set by how alive it is. Freshly generated
  alive pixels are red, while pixels that are just at the aliveness
  threshold are dark blue.

  The '-'/'_' key decreases the aliveness threshold, and the '+'/'=' key
  increases it.

------------------------------------------------------------------------

