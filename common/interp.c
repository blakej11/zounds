/*
 * interp.c - controls the image interpolation filter.
 * This is an attempt to make some "jumpy" core algorithms look smoother.
 *
 * This attempts to make transitions between successive images appear
 * smooth, by generating a series of images made of linear interpolations.
 * It operates on data from datasrc.c - i.e. cl_datavec's of data with
 * each vector component in the range [min, max].  ("min" and "max" are
 * specified in the call to interp_step().)  It doesn't know anything
 * about the meaning of the data; it simply assumes that it's meaningful
 * to perform linear interpolation on it.
 *
 * In practice, this doesn't work as well as I might hope.  What I really
 * want is something that interpolates "logically" -- causing larger jumps
 * in the overall image to be broken down into smaller jumps.  But, outside
 * of tweakable parameters in the core algorithm, that can't be done in any
 * fully general sense.
 *
 * When comparing two data points to perform linear interpolation, there
 * are a couple different approaches that can be taken:
 *
 * - Always move from the older data point to the newer one.  For example,
 *   the midpoint between 0.7 and 0.4 would be 0.55.
 *
 * - Always move in one direction (positive or negative), wrapping around
 *   at max or min as necesssary.  Positive wrapping (with min=0 and max=1)
 *   would cause the midpoint between 0.7 and 0.4 to be 0.05, not 0.55.
 *
 * The first approach is smoother, but also winds up avoiding some of the
 * more interesting areas of the data (especially areas with saturation or
 * value of 0 or 1).
 *
 * This code is enabled by having the core algorithm's preinit() routine
 * call interp_enable(), passing in the default and maximum amount of
 * interpolation desired.  interp_load() and interp_step() are then used
 * to interpose on core_load() and core_step() respectively.
 */
#include <strings.h>
#include <assert.h>

#include "common.h"

#include "debug.h"
#include "interp.h"
#include "module.h"
#include "opencl.h"
#include "param.h"

static void	interp_adjust(void);

/* ------------------------------------------------------------------ */

/*
 * This keeps up to NINTERP images queued up for interpolation.  Although
 * we only need 2 to interpolate between, the third gives us something to
 * work on immediately once we've finished an older one.
 *
 * In practice this doesn't buy us much, but if there were a second OpenCL
 * command queue that was dedicated for interpolation rendering requests,
 * it could look pretty nice.
 */
#define	NINTERP		3

static struct {
	bool		enabled;	/* is this used? */

	kernel_data_t	kernel;		/* interpolation kernel */
	cl_mem		bounds[NINTERP]; /* images to interpolate between */
	param_id_t	id;

	int		fr_next;	/* next image slot */
	int		fr_queued;	/* number of valid images queued */
	int		interp_cur;	/* current interpolation distance */
	int		interp_total;	/* total interpolation distance */
} Interp;

/* ------------------------------------------------------------------ */

/*
 * Reset the state of the interpolation filter.
 */
static void
interp_reset(void)
{
	Interp.fr_next = 0;
	Interp.fr_queued = 0;
	Interp.interp_cur = 0;
}

static void
interp_alloc(void)
{
	for (int i = 0; i < NINTERP; i++) {
		if (Interp.bounds[i] == NULL) {
			Interp.bounds[i] = 
			    ocl_datavec_image_create(Width, Height);
		}
	}
}

static void
interp_free(void)
{
	for (int i = 0; i < NINTERP; i++) {
		if (Interp.bounds[i] != NULL) {
			buffer_free(&Interp.bounds[i]);
		}
	}
}

static void
interp_init(void)
{
	if (!Interp.enabled) {
		return;
	}

	kernel_create(&Interp.kernel, "interpolate");

	/*
	 * interp_adjust() will allocate Interp.bounds[*] as necessary.
	 * If interp_total is 1, there's nothing to interpolate between,
	 * so we don't allocate anything.
	 */
	Interp.interp_total = 1;
	interp_reset();

	param_cb_register(Interp.id, interp_adjust);
}

static void
interp_fini(void)
{
	if (!Interp.enabled) {
		return;
	}

	param_cb_unregister(Interp.id, interp_adjust);

	interp_free();
	interp_reset();
	kernel_cleanup(&Interp.kernel);
}

const module_ops_t	interp_ops = {
	NULL,
	interp_init,
	interp_fini
};

/*
 * This must be called from core_preinit() if we're using the interpolator,
 * and shouldn't be called otherwise.
 */
void
interp_enable(int dflt, int max)
{
	param_init_t	pi;

	bzero(&pi, sizeof (pi));

	/*
	 * This parameter controls the number of interpolated images between
	 * each successive pair of images generated by the core algorithm.
	 */
	pi.pi_min = 1;
	pi.pi_default = MAX(1, dflt);
	pi.pi_max = MAX(1, max);
	pi.pi_units = 1;
	pi.pi_ap_freq = APF_OFF;	/* not quite so great */
	pi.pi_ap_rate = APR_HIGH;	/* not quite so great */
	pi.pi_name = "interpolation";
	Interp.id = param_register(&pi);

	param_key_register('i', KB_DEFAULT, Interp.id, -1);
	param_key_register('I', KB_DEFAULT, Interp.id,  1);
	debug_register_toggle('i', "interpolation", DB_INTERP, NULL);

	Interp.enabled = true;
	debug(DB_INTERP, "Interpolation enabled\n");
}

/* ------------------------------------------------------------------ */

/*
 * Called when the interpolation parameter changes.
 *
 * This parameter tracks the number of intermediate steps to display
 * between two successive "real" images.
 */
static void
interp_adjust(void)
{
	const int	ototal = Interp.interp_total;
	const int	ntotal = param_int(Interp.id);

	if (ototal == ntotal) {
		return;
	}

	debug(DB_INTERP, "Interpolation: %d -> %d total\n", ototal, ntotal);

	assert(ntotal >= 1);

	/*
	 * Allocate or free buffer space as needed.
	 */
	if (ntotal > 1 && ototal == 1) {
		assert(Interp.interp_cur == 0);
		interp_alloc();
	} else if (ntotal == 1 && ototal > 1) {
		if (Interp.fr_queued == 0) {
			interp_free();
		}
	}

	Interp.interp_total = ntotal;

	/*
	 * If the number of steps drops below our current step,
	 * reset the current step so we don't go off the end.
	 */
	if (Interp.interp_cur >= Interp.interp_total) {
		Interp.interp_cur = Interp.interp_total - 1;
	}

	debug(DB_INTERP, "Interpolation: now at %d / %d\n",
	    Interp.interp_cur, Interp.interp_total);
}

/* ------------------------------------------------------------------ */

/*
 * Make a copy of the data being loaded into the core algorithm.
 */
static void
interp_copy(cl_mem data)
{
	const int	idx = Interp.fr_next % NINTERP;

	assert(Interp.interp_total > 1);

	debug(DB_INTERP, "Interpolation: copying into %d\n", idx);

	ocl_image_copy(data, Interp.bounds[idx], Width, Height);
	Interp.fr_next++;
	Interp.fr_queued++;
}

void
interp_load(cl_mem data, void (*load)(cl_mem))
{
	assert(Interp.enabled);

	if (Interp.interp_total > 1) {
		interp_reset();
		interp_copy(data);
	}
	(*load)(data);
}

/*
 * Let the GPU do the "hard work".  Not that linear interpolation is
 * all that hard, but the images are in the GPU's memory anyway.
 */
static void
interpolate(cl_mem start, cl_mem end,
    float amount, float min, float max, cl_mem result)
{
	kernel_data_t	*const	kd = &Interp.kernel;
	int			arg;

	arg = 0;
	kernel_setarg(kd, arg++, sizeof (pix_t), &Width);
	kernel_setarg(kd, arg++, sizeof (pix_t), &Height);
	kernel_setarg(kd, arg++, sizeof (cl_mem), &start);
	kernel_setarg(kd, arg++, sizeof (cl_mem), &end);
	kernel_setarg(kd, arg++, sizeof (float), &amount);
	kernel_setarg(kd, arg++, sizeof (float), &min);
	kernel_setarg(kd, arg++, sizeof (float), &max);
	kernel_setarg(kd, arg++, sizeof (cl_mem), &result);

	kernel_invoke(kd, 2, NULL, NULL);
}

/*
 * The interpolation filter.  Interposes on core_step().
 */
void
interp_step(cl_mem result, float min, float max, void (*step)(cl_mem))
{
	assert(Interp.interp_total > 0);
	assert(Interp.enabled);

	if (Interp.interp_total == 1) {
		/*
		 * We're not doing any interpolation.
		 *
		 * If we have any queued images that we don't need anymore,
		 * use those as our results before going back to the core.
		 */
		if (Interp.fr_queued > 0) {
			const int	idx =
			    (Interp.fr_next - Interp.fr_queued) % NINTERP;

			ocl_image_copy(Interp.bounds[idx], result,
			    Width, Height);
			Interp.fr_queued--;

			if (Interp.fr_queued == 0) {
				interp_free();
			}
		} else {
			(*step)(result);
		}

		return;
	}

	/*
	 * Do we need to add to our queue?
	 */
	if (Interp.fr_queued < NINTERP) {
		(*step)(result);
		interp_copy(result);	/* increases fr_queued */
	}

	/*
	 * If we have enough queued up to do interpolation (that is,
	 * more than one), fire off a request to the GPU.
	 */
	if (Interp.fr_queued > 1) {
		assert(Interp.interp_cur < Interp.interp_total);

		const int	start =
		    (Interp.fr_next - Interp.fr_queued) % NINTERP;
		const int	end =
		    (start + 1) % NINTERP;

		Interp.interp_cur++;

		debug(DB_INTERP, "Interpolation: "
		    "doing %d/%d of %d->%d (%d queued, %d total)\n",
		    Interp.interp_cur, Interp.interp_total, start, end,
		    Interp.fr_queued, Interp.fr_next);

		interpolate(Interp.bounds[start], Interp.bounds[end],
		    (float)Interp.interp_cur / (float)Interp.interp_total,
		    min, max, result);
	}

	/*
	 * If we've gotten to the end of this pair, discard the old image
	 * to make space for a new one.
	 */
	if (Interp.interp_cur == Interp.interp_total) {
		Interp.interp_cur = 0;
		Interp.fr_queued--;
	}
}
